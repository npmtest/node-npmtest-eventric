{"/home/travis/build/npmtest/node-npmtest-eventric/test.js":"/* istanbul instrument in package npmtest_eventric */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eventric/lib.npmtest_eventric.js":"/* istanbul instrument in package npmtest_eventric */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eventric = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eventric = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eventric/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eventric && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eventric */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eventric\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eventric.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eventric.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eventric.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eventric.__dirname + '/lib.npmtest_eventric.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eventric/node_modules/eventric/dist/release/eventric.js":"(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eventric\"] = factory();\n\telse\n\t\troot[\"eventric\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context, Eventric, Projection, Remote, remoteContextHash, uuidGenerator,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n\tContext = __webpack_require__(2);\n\n\tRemote = __webpack_require__(19);\n\n\tProjection = __webpack_require__(17);\n\n\tuuidGenerator = __webpack_require__(10);\n\n\tremoteContextHash = {};\n\n\tEventric = (function() {\n\t  function Eventric() {\n\t    this._handleRemoteRPCRequest = bind(this._handleRemoteRPCRequest, this);\n\t    var GlobalContext, InmemoryStore, inmemoryRemote;\n\t    this._logger = __webpack_require__(22);\n\t    GlobalContext = __webpack_require__(24);\n\t    inmemoryRemote = __webpack_require__(21);\n\t    InmemoryStore = __webpack_require__(26);\n\t    this._contexts = {};\n\t    this._params = {};\n\t    this._domainEventHandlers = {};\n\t    this._domainEventHandlersAll = [];\n\t    this._storeDefinition = null;\n\t    this._remoteEndpoints = [];\n\t    this._globalProjections = [];\n\t    this._globalContext = new GlobalContext;\n\t    this.addRemoteEndpoint(inmemoryRemote.endpoint);\n\t    this.setStore(InmemoryStore, {});\n\t  }\n\n\t  Eventric.prototype.setLogger = function(logger) {\n\t    return this._logger = logger;\n\t  };\n\n\t  Eventric.prototype.getLogger = function() {\n\t    return this._logger;\n\t  };\n\n\t  Eventric.prototype.setLogLevel = function(logLevel) {\n\t    return this._logger.setLogLevel(logLevel);\n\t  };\n\n\t  Eventric.prototype.setStore = function(StoreClass, storeOptions) {\n\t    if (storeOptions == null) {\n\t      storeOptions = {};\n\t    }\n\t    return this._storeDefinition = {\n\t      Class: StoreClass,\n\t      options: storeOptions\n\t    };\n\t  };\n\n\t  Eventric.prototype.getStoreDefinition = function() {\n\t    return this._storeDefinition;\n\t  };\n\n\t  Eventric.prototype.context = function(name) {\n\t    var context;\n\t    if (!name) {\n\t      throw new Error('Contexts must have a name');\n\t    }\n\t    context = new Context(name);\n\t    context.subscribeToAllDomainEvents((function(_this) {\n\t      return function(domainEvent) {\n\t        return _this._delegateDomainEventToRemoteEndpoints(domainEvent);\n\t      };\n\t    })(this));\n\t    this._contexts[name] = context;\n\t    return context;\n\t  };\n\n\t  Eventric.prototype.initializeGlobalProjections = function() {\n\t    var initializeGlobalProjectionsPromise, startOfInitialization;\n\t    if (!this._projectionService) {\n\t      this._projectionService = new Projection(this._globalContext);\n\t    }\n\t    startOfInitialization = new Date;\n\t    this._logger.debug('eventric global projections initializing');\n\t    initializeGlobalProjectionsPromise = Promise.resolve();\n\t    this._globalProjections.forEach((function(_this) {\n\t      return function(globalProjection) {\n\t        return initializeGlobalProjectionsPromise = initializeGlobalProjectionsPromise.then(function() {\n\t          return _this._projectionService.initializeInstance(globalProjection, {});\n\t        });\n\t      };\n\t    })(this));\n\t    initializeGlobalProjectionsPromise.then((function(_this) {\n\t      return function() {\n\t        var durationOfInitialization, endOfInitialization;\n\t        endOfInitialization = new Date;\n\t        durationOfInitialization = endOfInitialization - startOfInitialization;\n\t        return _this._logger.debug(\"eventric global projections initialized after \" + durationOfInitialization + \"ms\");\n\t      };\n\t    })(this));\n\t    return initializeGlobalProjectionsPromise;\n\t  };\n\n\t  Eventric.prototype.addGlobalProjection = function(projectionObject) {\n\t    return this._globalProjections.push(projectionObject);\n\t  };\n\n\t  Eventric.prototype.getRegisteredContextNames = function() {\n\t    return Object.keys(this._contexts);\n\t  };\n\n\t  Eventric.prototype.setDefaultRemoteClient = function(remoteClient) {\n\t    return this._defaultRemoteClient = remoteClient;\n\t  };\n\n\t  Eventric.prototype.remoteContext = function(contextName) {\n\t    var remote;\n\t    if (!contextName) {\n\t      throw new Error('Missing context name');\n\t    }\n\t    if (remoteContextHash[contextName]) {\n\t      return remoteContextHash[contextName];\n\t    }\n\t    remote = remoteContextHash[contextName] = new Remote(contextName);\n\t    if (this._defaultRemoteClient) {\n\t      remote.setClient(this._defaultRemoteClient);\n\t    }\n\t    return remote;\n\t  };\n\n\t  Eventric.prototype.addRemoteEndpoint = function(remoteEndpoint) {\n\t    this._remoteEndpoints.push(remoteEndpoint);\n\t    return remoteEndpoint.setRPCHandler(this._handleRemoteRPCRequest);\n\t  };\n\n\t  Eventric.prototype.generateUuid = function() {\n\t    return uuidGenerator.generateUuid();\n\t  };\n\n\t  Eventric.prototype._handleRemoteRPCRequest = function(request, callback) {\n\t    var context, error;\n\t    context = this._contexts[request.contextName];\n\t    if (!context) {\n\t      error = new Error(\"Tried to handle Remote RPC with not registered context \" + request.contextName);\n\t      this._logger.error(error, '\\n', error.stack);\n\t      callback(error, null);\n\t      return;\n\t    }\n\t    if (Remote.ALLOWED_RPC_OPERATIONS.indexOf(request.functionName) === -1) {\n\t      error = new Error(\"RPC operation '\" + request.functionName + \"' not allowed\");\n\t      this._logger.error(error, '\\n', error.stack);\n\t      callback(error, null);\n\t      return;\n\t    }\n\t    if (!(request.functionName in context)) {\n\t      error = new Error(\"Remote RPC function \" + request.functionName + \" not found on Context \" + request.contextName);\n\t      this._logger.error(error, '\\n', error.stack);\n\t      callback(error, null);\n\t      return;\n\t    }\n\t    return context[request.functionName].apply(context, request.args).then(function(result) {\n\t      return callback(null, result);\n\t    })[\"catch\"](function(error) {\n\t      return callback(error);\n\t    });\n\t  };\n\n\t  Eventric.prototype._delegateDomainEventToRemoteEndpoints = function(domainEvent) {\n\t    return Promise.all(this._remoteEndpoints.map(function(remoteEndpoint) {\n\t      var publishPromise;\n\t      publishPromise = Promise.resolve().then(function() {\n\t        return remoteEndpoint.publish(domainEvent.context, domainEvent.name, domainEvent);\n\t      });\n\t      if (domainEvent.aggregate) {\n\t        publishPromise = publishPromise.then(function() {\n\t          return remoteEndpoint.publish(domainEvent.context, domainEvent.name, domainEvent.aggregate.id, domainEvent);\n\t        });\n\t      }\n\t      return publishPromise;\n\t    }));\n\t  };\n\n\t  return Eventric;\n\n\t})();\n\n\tmodule.exports = new Eventric;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar AggregateRepository, Context, domainEventService,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t  slice = [].slice;\n\n\tAggregateRepository = __webpack_require__(4);\n\n\tdomainEventService = __webpack_require__(12);\n\n\tContext = (function() {\n\t  function Context(name) {\n\t    var EventBus, Projection;\n\t    this.name = name;\n\t    this._getAggregateRepository = bind(this._getAggregateRepository, this);\n\t    EventBus = __webpack_require__(14);\n\t    Projection = __webpack_require__(17);\n\t    this._logger = __webpack_require__(13).getLogger();\n\t    this._isInitialized = false;\n\t    this._isDestroyed = false;\n\t    this._di = {\n\t      $query: (function(_this) {\n\t        return function() {\n\t          return _this.query.apply(_this, arguments);\n\t        };\n\t      })(this)\n\t    };\n\t    this._aggregateClasses = {};\n\t    this._commandHandlers = {};\n\t    this._queryHandlers = {};\n\t    this._domainEventPayloadConstructors = {};\n\t    this._domainEventHandlers = {};\n\t    this._projectionObjects = [];\n\t    this._repositoryInstances = {};\n\t    this._storeInstance = null;\n\t    this._pendingPromises = [];\n\t    this._eventBus = new EventBus;\n\t    this._projectionService = new Projection(this);\n\t  }\n\n\t  Context.prototype.initialize = function() {\n\t    var startOfInitialization;\n\t    startOfInitialization = new Date;\n\t    this._logger.debug(\"eventric context \\\"\" + this.name + \"\\\" initializing\");\n\t    return this._initializeStore().then((function(_this) {\n\t      return function() {\n\t        return _this._initializeProjections();\n\t      };\n\t    })(this)).then((function(_this) {\n\t      return function() {\n\t        var durationOfInitialization, endOfInitialization;\n\t        endOfInitialization = new Date;\n\t        durationOfInitialization = endOfInitialization - startOfInitialization;\n\t        _this._logger.debug(\"eventric context \\\"\" + _this.name + \"\\\" initialized after \" + durationOfInitialization + \"ms\");\n\t        return _this._isInitialized = true;\n\t      };\n\t    })(this));\n\t  };\n\n\t  Context.prototype._initializeStore = function() {\n\t    var eventric, initializeStorePromise, storeDefinition;\n\t    eventric = __webpack_require__(1);\n\t    storeDefinition = eventric.getStoreDefinition();\n\t    this._storeInstance = new storeDefinition.Class;\n\t    initializeStorePromise = this._storeInstance.initialize(this, storeDefinition.options);\n\t    return initializeStorePromise;\n\t  };\n\n\t  Context.prototype._initializeProjections = function() {\n\t    var initializeProjectionsPromise;\n\t    initializeProjectionsPromise = Promise.resolve();\n\t    this._projectionObjects.forEach((function(_this) {\n\t      return function(projectionObject) {\n\t        return initializeProjectionsPromise = initializeProjectionsPromise.then(function() {\n\t          return _this._projectionService.initializeInstance(projectionObject, {});\n\t        });\n\t      };\n\t    })(this));\n\t    return initializeProjectionsPromise;\n\t  };\n\n\t  Context.prototype.defineDomainEvent = function(domainEventName, DomainEventPayloadConstructor) {\n\t    this._domainEventPayloadConstructors[domainEventName] = DomainEventPayloadConstructor;\n\t    return this;\n\t  };\n\n\t  Context.prototype.defineDomainEvents = function(domainEventClassesObj) {\n\t    var DomainEventPayloadConstructor, domainEventName;\n\t    for (domainEventName in domainEventClassesObj) {\n\t      DomainEventPayloadConstructor = domainEventClassesObj[domainEventName];\n\t      this.defineDomainEvent(domainEventName, DomainEventPayloadConstructor);\n\t    }\n\t    return this;\n\t  };\n\n\t  Context.prototype.addCommandHandlers = function(commandHandlers) {\n\t    var commandFunction, commandHandlerName;\n\t    for (commandHandlerName in commandHandlers) {\n\t      commandFunction = commandHandlers[commandHandlerName];\n\t      this._commandHandlers[commandHandlerName] = commandFunction;\n\t    }\n\t    return this;\n\t  };\n\n\t  Context.prototype.addQueryHandlers = function(queryHandlers) {\n\t    var queryFunction, queryHandlerName;\n\t    for (queryHandlerName in queryHandlers) {\n\t      queryFunction = queryHandlers[queryHandlerName];\n\t      this._queryHandlers[queryHandlerName] = queryFunction;\n\t    }\n\t    return this;\n\t  };\n\n\t  Context.prototype.addAggregate = function(aggregateName, AggregateClass) {\n\t    this._aggregateClasses[aggregateName] = AggregateClass;\n\t    return this;\n\t  };\n\n\t  Context.prototype.subscribeToAllDomainEvents = function(handlerFn) {\n\t    var domainEventHandler;\n\t    domainEventHandler = (function(_this) {\n\t      return function() {\n\t        return handlerFn.apply(_this._di, arguments);\n\t      };\n\t    })(this);\n\t    return this._eventBus.subscribeToAllDomainEvents(domainEventHandler);\n\t  };\n\n\t  Context.prototype.subscribeToDomainEvent = function(domainEventName, handlerFn) {\n\t    var domainEventHandler;\n\t    domainEventHandler = (function(_this) {\n\t      return function() {\n\t        return handlerFn.apply(_this._di, arguments);\n\t      };\n\t    })(this);\n\t    return this._eventBus.subscribeToDomainEvent(domainEventName, domainEventHandler);\n\t  };\n\n\t  Context.prototype.subscribeToDomainEvents = function(domainEventHandlersObj) {\n\t    var domainEventName, handlerFn, results;\n\t    results = [];\n\t    for (domainEventName in domainEventHandlersObj) {\n\t      handlerFn = domainEventHandlersObj[domainEventName];\n\t      results.push(this.subscribeToDomainEvent(domainEventName, handlerFn));\n\t    }\n\t    return results;\n\t  };\n\n\t  Context.prototype.subscribeToDomainEventWithAggregateId = function(domainEventName, aggregateId, handlerFn) {\n\t    var domainEventHandler;\n\t    domainEventHandler = (function(_this) {\n\t      return function() {\n\t        return handlerFn.apply(_this._di, arguments);\n\t      };\n\t    })(this);\n\t    return this._eventBus.subscribeToDomainEventWithAggregateId(domainEventName, aggregateId, domainEventHandler);\n\t  };\n\n\t  Context.prototype.unsubscribeFromDomainEvent = function(subscriberId) {\n\t    return this._eventBus.unsubscribe(subscriberId);\n\t  };\n\n\t  Context.prototype.addProjection = function(projectionObject) {\n\t    this._projectionObjects.push(projectionObject);\n\t    return this;\n\t  };\n\n\t  Context.prototype.destroyProjectionInstance = function(projectionId) {\n\t    return this._projectionService.destroyInstance(projectionId, this);\n\t  };\n\n\t  Context.prototype.getDomainEventPayloadConstructor = function(domainEventName) {\n\t    return this._domainEventPayloadConstructors[domainEventName];\n\t  };\n\n\t  Context.prototype.getDomainEventsStore = function() {\n\t    return this._storeInstance;\n\t  };\n\n\t  Context.prototype.getEventBus = function() {\n\t    return this._eventBus;\n\t  };\n\n\t  Context.prototype.findDomainEventsByName = function() {\n\t    var findArguments;\n\t    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t    return new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        var ref;\n\t        return (ref = _this.getDomainEventsStore()).findDomainEventsByName.apply(ref, slice.call(findArguments).concat([function(err, domainEvents) {\n\t          if (err) {\n\t            return reject(err);\n\t          }\n\t          domainEvents = domainEventService.sortDomainEventsById(domainEvents);\n\t          return resolve(domainEvents);\n\t        }]));\n\t      };\n\t    })(this));\n\t  };\n\n\t  Context.prototype.findDomainEventsByNameAndAggregateId = function() {\n\t    var findArguments;\n\t    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t    return new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        var ref;\n\t        return (ref = _this.getDomainEventsStore()).findDomainEventsByNameAndAggregateId.apply(ref, slice.call(findArguments).concat([function(err, domainEvents) {\n\t          if (err) {\n\t            return reject(err);\n\t          }\n\t          domainEvents = domainEventService.sortDomainEventsById(domainEvents);\n\t          return resolve(domainEvents);\n\t        }]));\n\t      };\n\t    })(this));\n\t  };\n\n\t  Context.prototype.command = function(commandName, params) {\n\t    var executingCommand, paramsWithHiddenPasswordValue;\n\t    if (this._isDestroyed) {\n\t      paramsWithHiddenPasswordValue = this._hidePasswordValue(params);\n\t      return Promise.reject(new Error(\"Context \" + this.name + \" was destroyed, cannot execute command \" + commandName + \" with arguments\\n\" + (JSON.stringify(paramsWithHiddenPasswordValue))));\n\t    }\n\t    executingCommand = new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        var commandServicesToInject;\n\t        _this._verifyContextIsInitialized(commandName);\n\t        if (!_this._commandHandlers[commandName]) {\n\t          throw new Error(\"Given command \" + commandName + \" not registered on context\");\n\t        }\n\t        commandServicesToInject = _this._getCommandServicesToInject();\n\t        return Promise.resolve().then(function() {\n\t          return _this._commandHandlers[commandName].apply(commandServicesToInject, [params]);\n\t        }).then(function(result) {\n\t          _this._logger.debug('Completed Command', commandName);\n\t          return resolve(result);\n\t        })[\"catch\"](function(error) {\n\t          var commandErrorMessage;\n\t          paramsWithHiddenPasswordValue = _this._hidePasswordValue(params);\n\t          commandErrorMessage = \"Command \\\"\" + commandName + \"\\\" with arguments \" + (JSON.stringify(paramsWithHiddenPasswordValue)) + \" of context \\\"\" + _this.name + \"\\\"\\nrejects with an error\";\n\t          if (!error) {\n\t            reject(new Error(commandErrorMessage));\n\t            return;\n\t          }\n\t          error = _this._extendError(error, commandErrorMessage);\n\t          return reject(error);\n\t        });\n\t      };\n\t    })(this));\n\t    this._addPendingPromise(executingCommand);\n\t    return executingCommand;\n\t  };\n\n\t  Context.prototype._hidePasswordValue = function(params) {\n\t    if (params.password) {\n\t      params.password = '******';\n\t    }\n\t    return params;\n\t  };\n\n\t  Context.prototype._getCommandServicesToInject = function() {\n\t    var diFn, diFnName, ref, servicesToInject;\n\t    servicesToInject = {};\n\t    ref = this._di;\n\t    for (diFnName in ref) {\n\t      diFn = ref[diFnName];\n\t      servicesToInject[diFnName] = diFn;\n\t    }\n\t    servicesToInject.$aggregate = {\n\t      create: (function(_this) {\n\t        return function() {\n\t          var aggregateName, aggregateParams, aggregateRepository;\n\t          aggregateName = arguments[0], aggregateParams = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          aggregateRepository = _this._getAggregateRepository(aggregateName);\n\t          return aggregateRepository.create.apply(aggregateRepository, aggregateParams);\n\t        };\n\t      })(this),\n\t      load: (function(_this) {\n\t        return function(aggregateName, aggregateId) {\n\t          var aggregateRepository;\n\t          aggregateRepository = _this._getAggregateRepository(aggregateName);\n\t          return aggregateRepository.load(aggregateId);\n\t        };\n\t      })(this)\n\t    };\n\t    return servicesToInject;\n\t  };\n\n\t  Context.prototype._extendError = function(error, additionalMessage) {\n\t    error.originalErrorMessage = error.message;\n\t    error.message = additionalMessage + \" - original error message: \" + error.originalErrorMessage;\n\t    return error;\n\t  };\n\n\t  Context.prototype._getAggregateRepository = function(aggregateName) {\n\t    return new AggregateRepository({\n\t      aggregateName: aggregateName,\n\t      AggregateClass: this._aggregateClasses[aggregateName],\n\t      context: this\n\t    });\n\t  };\n\n\t  Context.prototype._addPendingPromise = function(pendingPromise) {\n\t    var alwaysResolvingPromise;\n\t    alwaysResolvingPromise = pendingPromise[\"catch\"](function() {});\n\t    this._pendingPromises.push(alwaysResolvingPromise);\n\t    return alwaysResolvingPromise.then((function(_this) {\n\t      return function() {\n\t        return _this._pendingPromises.splice(_this._pendingPromises.indexOf(alwaysResolvingPromise), 1);\n\t      };\n\t    })(this));\n\t  };\n\n\t  Context.prototype.query = function(queryName, params) {\n\t    return new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        _this._logger.debug('Got Query', queryName);\n\t        _this._verifyContextIsInitialized(queryName);\n\t        if (!_this._queryHandlers[queryName]) {\n\t          reject(new Error(\"Given query \" + queryName + \" not registered on context\"));\n\t          return;\n\t        }\n\t        return Promise.resolve().then(function() {\n\t          return _this._queryHandlers[queryName].apply(_this._di, [params]);\n\t        }).then(function(result) {\n\t          _this._logger.debug(\"Completed Query \" + queryName + \" with Result \" + result);\n\t          return resolve(result);\n\t        })[\"catch\"](function(error) {\n\t          var paramsWithHiddenPasswordValue, queryErrorMessage;\n\t          paramsWithHiddenPasswordValue = _this._hidePasswordValue(params);\n\t          queryErrorMessage = \"Query \\\"\" + queryName + \"\\\" with arguments \" + (JSON.stringify(paramsWithHiddenPasswordValue)) + \" of context \\\"\" + _this.name + \"\\\"\\nrejects with an error\";\n\t          if (!error) {\n\t            reject(new Error(queryErrorMessage));\n\t            return;\n\t          }\n\t          error = _this._extendError(error, queryErrorMessage);\n\t          return reject(error);\n\t        });\n\t      };\n\t    })(this));\n\t  };\n\n\t  Context.prototype._verifyContextIsInitialized = function(methodName) {\n\t    if (!this._isInitialized) {\n\t      throw new Error(\"Context \" + this.name + \" not initialized yet, cannot execute \" + methodName);\n\t    }\n\t  };\n\n\t  Context.prototype.destroy = function() {\n\t    return Promise.all(this._pendingPromises).then((function(_this) {\n\t      return function() {\n\t        return _this._eventBus.destroy();\n\t      };\n\t    })(this)).then((function(_this) {\n\t      return function() {\n\t        return _this._isDestroyed = true;\n\t      };\n\t    })(this));\n\t  };\n\n\t  return Context;\n\n\t})();\n\n\tmodule.exports = Context;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(5);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Aggregate, AggregateRepository, domainEventService, uuidGenerator,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n\tAggregate = __webpack_require__(6);\n\n\tuuidGenerator = __webpack_require__(10);\n\n\tdomainEventService = __webpack_require__(12);\n\n\tAggregateRepository = (function() {\n\t  function AggregateRepository(params) {\n\t    this.save = bind(this.save, this);\n\t    this.create = bind(this.create, this);\n\t    this.load = bind(this.load, this);\n\t    this._logger = __webpack_require__(13).getLogger();\n\t    this._aggregateName = params.aggregateName;\n\t    this._AggregateClass = params.AggregateClass;\n\t    this._context = params.context;\n\t    this._store = this._context.getDomainEventsStore();\n\t  }\n\n\t  AggregateRepository.prototype.load = function(aggregateId) {\n\t    return new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        return _this._store.findDomainEventsByAggregateId(aggregateId, function(error, domainEvents) {\n\t          var aggregate, aggregateDeletedEvent, domainEvent, i;\n\t          if (error) {\n\t            reject(error);\n\t            return;\n\t          }\n\t          if (!(domainEvents != null ? domainEvents.length : void 0)) {\n\t            reject(new Error(\"No domainEvents for aggregate of type \" + _this._aggregateName + \" with \" + aggregateId + \" available\"));\n\t            return;\n\t          }\n\t          domainEvents = domainEventService.sortDomainEventsById(domainEvents);\n\t          aggregateDeletedEvent = null;\n\t          for (i = domainEvents.length - 1; i >= 0; i += -1) {\n\t            domainEvent = domainEvents[i];\n\t            if (domainEvent.name.indexOf(_this._aggregateName + \"Deleted\") > -1) {\n\t              aggregateDeletedEvent = domainEvent;\n\t              break;\n\t            }\n\t          }\n\t          if (aggregateDeletedEvent != null) {\n\t            reject(new Error(\"Aggregate of type \" + _this._aggregateName + \" with id \" + aggregateId + \" is marked as deleted because of domain event \" + aggregateDeletedEvent.name + \" with domain event id \" + aggregateDeletedEvent.id));\n\t            return;\n\t          }\n\t          aggregate = new Aggregate(_this._context, _this._aggregateName, _this._AggregateClass);\n\t          aggregate.setId(aggregateId);\n\t          aggregate.applyDomainEvents(domainEvents);\n\t          _this._installSaveFunctionOnAggregateInstance(aggregate);\n\t          return resolve(aggregate.instance);\n\t        });\n\t      };\n\t    })(this));\n\t  };\n\n\t  AggregateRepository.prototype.create = function(params, id) {\n\t    if (id == null) {\n\t      id = null;\n\t    }\n\t    return Promise.resolve().then((function(_this) {\n\t      return function() {\n\t        var aggregate;\n\t        aggregate = new Aggregate(_this._context, _this._aggregateName, _this._AggregateClass);\n\t        if (typeof aggregate.instance.create !== 'function') {\n\t          throw new Error('No create function on aggregate');\n\t        }\n\t        if (id != null) {\n\t          aggregate.setId(id);\n\t        } else {\n\t          aggregate.setId(uuidGenerator.generateUuid());\n\t        }\n\t        _this._installSaveFunctionOnAggregateInstance(aggregate);\n\t        return Promise.resolve(aggregate.instance.create(params)).then(function() {\n\t          return aggregate.instance;\n\t        });\n\t      };\n\t    })(this));\n\t  };\n\n\t  AggregateRepository.prototype._installSaveFunctionOnAggregateInstance = function(aggregate) {\n\t    return aggregate.instance.$save = (function(_this) {\n\t      return function() {\n\t        return _this.save(aggregate);\n\t      };\n\t    })(this);\n\t  };\n\n\t  AggregateRepository.prototype.save = function(aggregate) {\n\t    return Promise.resolve().then((function(_this) {\n\t      return function() {\n\t        var domainEvents, saveDomainEventQueue, savedDomainEvents;\n\t        if (!aggregate) {\n\t          throw new Error(\"Tried to save unknown aggregate \" + _this._aggregateName);\n\t        }\n\t        domainEvents = aggregate.getNewDomainEvents();\n\t        if (!(domainEvents != null ? domainEvents.length : void 0)) {\n\t          throw new Error(\"No new domain events to save for aggregate of type \" + _this._aggregateName + \" with id \" + aggregate.id);\n\t        }\n\t        _this._logger.debug(\"Going to Save and Publish \" + domainEvents.length + \" DomainEvents from Aggregate \" + _this._aggregateName);\n\t        saveDomainEventQueue = Promise.resolve();\n\t        savedDomainEvents = [];\n\t        domainEvents.forEach(function(domainEvent) {\n\t          return saveDomainEventQueue = saveDomainEventQueue.then(function() {\n\t            return _this._store.saveDomainEvent(domainEvent).then(function(domainEvent) {\n\t              return savedDomainEvents.push(domainEvent);\n\t            });\n\t          });\n\t        });\n\t        return saveDomainEventQueue.then(function() {\n\t          savedDomainEvents.forEach(function(domainEvent) {\n\t            return _this._context.getEventBus().publishDomainEvent(domainEvent)[\"catch\"](function(error) {\n\t              return _this._logger.error(error, '\\n', error.stack);\n\t            });\n\t          });\n\t          return aggregate.id;\n\t        });\n\t      };\n\t    })(this));\n\t  };\n\n\t  return AggregateRepository;\n\n\t})();\n\n\tmodule.exports = AggregateRepository;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Aggregate, DomainEvent,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n\tDomainEvent = __webpack_require__(8);\n\n\tAggregate = (function() {\n\t  function Aggregate(_context, _name, AggregateClass) {\n\t    this._context = _context;\n\t    this._name = _name;\n\t    this.emitDomainEvent = bind(this.emitDomainEvent, this);\n\t    this._newDomainEvents = [];\n\t    this.instance = new AggregateClass;\n\t    this.instance.$emitDomainEvent = this.emitDomainEvent;\n\t  }\n\n\t  Aggregate.prototype.setId = function(id) {\n\t    this.id = id;\n\t    return this.instance.$id = this.id;\n\t  };\n\n\t  Aggregate.prototype.emitDomainEvent = function(domainEventName, domainEventPayload) {\n\t    var aggregate, domainEvent;\n\t    aggregate = {\n\t      id: this.id,\n\t      name: this._name\n\t    };\n\t    domainEvent = this._createDomainEvent(domainEventName, domainEventPayload, aggregate);\n\t    this._newDomainEvents.push(domainEvent);\n\t    return this._handleDomainEvent(domainEventName, domainEvent);\n\t  };\n\n\t  Aggregate.prototype._createDomainEvent = function(domainEventName, domainEventConstructorParams, aggregate) {\n\t    var DomainEventPayloadConstructor, payload;\n\t    DomainEventPayloadConstructor = this._context.getDomainEventPayloadConstructor(domainEventName);\n\t    if (!DomainEventPayloadConstructor) {\n\t      throw new Error(\"Tried to create domain event '\" + domainEventName + \"' which is not defined\");\n\t    }\n\t    payload = {};\n\t    DomainEventPayloadConstructor.apply(payload, [domainEventConstructorParams]);\n\t    return new DomainEvent({\n\t      name: domainEventName,\n\t      aggregate: aggregate,\n\t      context: this._context.name,\n\t      payload: payload\n\t    });\n\t  };\n\n\t  Aggregate.prototype._handleDomainEvent = function(domainEventName, domainEvent) {\n\t    if (this.instance[\"handle\" + domainEventName]) {\n\t      return this.instance[\"handle\" + domainEventName](domainEvent);\n\t    }\n\t  };\n\n\t  Aggregate.prototype.getNewDomainEvents = function() {\n\t    return this._newDomainEvents;\n\t  };\n\n\t  Aggregate.prototype.applyDomainEvents = function(domainEvents) {\n\t    var domainEvent, i, len, results;\n\t    results = [];\n\t    for (i = 0, len = domainEvents.length; i < len; i++) {\n\t      domainEvent = domainEvents[i];\n\t      results.push(this._applyDomainEvent(domainEvent));\n\t    }\n\t    return results;\n\t  };\n\n\t  Aggregate.prototype._applyDomainEvent = function(domainEvent) {\n\t    return this._handleDomainEvent(domainEvent.name, domainEvent);\n\t  };\n\n\t  return Aggregate;\n\n\t})();\n\n\tmodule.exports = Aggregate;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(9);\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar DomainEvent;\n\n\tDomainEvent = (function() {\n\t  function DomainEvent(params) {\n\t    this.id = params.id;\n\t    this.name = params.name;\n\t    this.payload = params.payload;\n\t    this.aggregate = params.aggregate;\n\t    this.context = params.context;\n\t    this.timestamp = new Date().getTime();\n\t  }\n\n\t  return DomainEvent;\n\n\t})();\n\n\tmodule.exports = DomainEvent;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(11);\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar UuidGenerator;\n\n\tUuidGenerator = (function() {\n\t  function UuidGenerator() {}\n\n\t  UuidGenerator.prototype._uuidTemplate = 'xxxxxxxx-xxxx-4xxx-vxxx-xxxxxxxxxxxx';\n\n\t  UuidGenerator.prototype.generateUuid = function() {\n\t    var uuid;\n\t    uuid = this._uuidTemplate.replace(/[xv]/g, function(characterToReplace) {\n\t      var randomNumber, variant;\n\t      randomNumber = Math.floor(Math.random() * 16);\n\t      if (characterToReplace === 'x') {\n\t        return randomNumber.toString(16);\n\t      } else {\n\t        variant = randomNumber & 0x3 | 0x8;\n\t        return variant.toString(16);\n\t      }\n\t    });\n\t    return uuid;\n\t  };\n\n\t  return UuidGenerator;\n\n\t})();\n\n\tmodule.exports = new UuidGenerator;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tvar DomainEventService;\n\n\tDomainEventService = (function() {\n\t  function DomainEventService() {}\n\n\t  DomainEventService.prototype.sortDomainEventsById = function(domainEvents) {\n\t    return domainEvents.sort(function(firstDomainEvent, secondDomainEvent) {\n\t      return firstDomainEvent.id - secondDomainEvent.id;\n\t    });\n\t  };\n\n\t  return DomainEventService;\n\n\t})();\n\n\tmodule.exports = new DomainEventService;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(15);\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventBus, Subscriber;\n\n\tSubscriber = __webpack_require__(16);\n\n\tEventBus = (function() {\n\t  function EventBus() {\n\t    this._subscribers = [];\n\t    this._subscriberId = 0;\n\t    this._eventPublishQueue = Promise.resolve();\n\t    this._isDestroyed = false;\n\t  }\n\n\t  EventBus.prototype.subscribeToAllDomainEvents = function(subscriberFunction) {\n\t    return this._subscribe('*', subscriberFunction);\n\t  };\n\n\t  EventBus.prototype.subscribeToDomainEvent = function(eventName, subscriberFunction) {\n\t    return this._subscribe(eventName, subscriberFunction);\n\t  };\n\n\t  EventBus.prototype.subscribeToDomainEventWithAggregateId = function(eventName, aggregateId, subscriberFunction) {\n\t    return this._subscribe(eventName + \"/\" + aggregateId, subscriberFunction);\n\t  };\n\n\t  EventBus.prototype._subscribe = function(eventName, subscriberFunction) {\n\t    return new Promise((function(_this) {\n\t      return function(resolve) {\n\t        var subscriber;\n\t        subscriber = new Subscriber({\n\t          eventName: eventName,\n\t          subscriberFunction: subscriberFunction,\n\t          subscriberId: _this._getNextSubscriberId()\n\t        });\n\t        _this._subscribers.push(subscriber);\n\t        return resolve(subscriber.subscriberId);\n\t      };\n\t    })(this));\n\t  };\n\n\t  EventBus.prototype._getNextSubscriberId = function() {\n\t    return this._subscriberId++;\n\t  };\n\n\t  EventBus.prototype.publishDomainEvent = function(domainEvent) {\n\t    return new Promise((function(_this) {\n\t      return function(resolve, reject) {\n\t        var publishOperation;\n\t        _this._verifyPublishIsPossible(domainEvent);\n\t        publishOperation = function() {\n\t          return _this._notifySubscribers(domainEvent).then(resolve)[\"catch\"](reject);\n\t        };\n\t        return _this._enqueueEventPublishing(publishOperation);\n\t      };\n\t    })(this));\n\t  };\n\n\t  EventBus.prototype._verifyPublishIsPossible = function(domainEvent) {\n\t    var errorMessage, ref;\n\t    if (this._isDestroyed) {\n\t      errorMessage = \"Event Bus was destroyed, cannot publish \" + domainEvent.name + \"\\nwith payload \" + (JSON.stringify(domainEvent.payload));\n\t      if ((ref = domainEvent.aggregate) != null ? ref.id : void 0) {\n\t        errorMessage += \" and aggregate id \" + domainEvent.aggregate.id;\n\t      }\n\t      throw new Error(errorMessage);\n\t    }\n\t  };\n\n\t  EventBus.prototype._notifySubscribers = function(domainEvent) {\n\t    return Promise.resolve().then((function(_this) {\n\t      return function() {\n\t        var subscribers;\n\t        subscribers = _this._getSubscribersForDomainEvent(domainEvent);\n\t        return Promise.all(subscribers.map(function(subscriber) {\n\t          return subscriber.subscriberFunction(domainEvent);\n\t        }));\n\t      };\n\t    })(this));\n\t  };\n\n\t  EventBus.prototype._getSubscribersForDomainEvent = function(domainEvent) {\n\t    var ref, subscribers;\n\t    subscribers = this._subscribers.filter(function(subscriber) {\n\t      return subscriber.eventName === '*';\n\t    });\n\t    subscribers = subscribers.concat(this._subscribers.filter(function(subscriber) {\n\t      return subscriber.eventName === domainEvent.name;\n\t    }));\n\t    if ((ref = domainEvent.aggregate) != null ? ref.id : void 0) {\n\t      subscribers = subscribers.concat(this._subscribers.filter(function(subscriber) {\n\t        return subscriber.eventName === (domainEvent.name + \"/\" + domainEvent.aggregate.id);\n\t      }));\n\t    }\n\t    return subscribers;\n\t  };\n\n\t  EventBus.prototype._enqueueEventPublishing = function(publishOperation) {\n\t    return this._eventPublishQueue = this._eventPublishQueue.then(publishOperation);\n\t  };\n\n\t  EventBus.prototype.unsubscribe = function(subscriberId) {\n\t    return Promise.resolve().then((function(_this) {\n\t      return function() {\n\t        return _this._subscribers = _this._subscribers.filter(function(subscriber) {\n\t          return subscriber.subscriberId !== subscriberId;\n\t        });\n\t      };\n\t    })(this));\n\t  };\n\n\t  EventBus.prototype.destroy = function() {\n\t    return this._waitForEventPublishQueue().then((function(_this) {\n\t      return function() {\n\t        return _this._isDestroyed = true;\n\t      };\n\t    })(this));\n\t  };\n\n\t  EventBus.prototype._waitForEventPublishQueue = function() {\n\t    var currentEventPublishQueue;\n\t    currentEventPublishQueue = this._eventPublishQueue;\n\t    return currentEventPublishQueue.then((function(_this) {\n\t      return function() {\n\t        if (_this._eventPublishQueue !== currentEventPublishQueue) {\n\t          return _this._waitForEventPublishQueue();\n\t        }\n\t      };\n\t    })(this));\n\t  };\n\n\t  return EventBus;\n\n\t})();\n\n\tmodule.exports = EventBus;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tvar Subscriber;\n\n\tSubscriber = (function() {\n\t  function Subscriber(arg) {\n\t    this.eventName = arg.eventName, this.subscriberFunction = arg.subscriberFunction, this.subscriberId = arg.subscriberId;\n\t  }\n\n\t  return Subscriber;\n\n\t})();\n\n\tmodule.exports = Subscriber;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(18);\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ProjectionService, uuidGenerator;\n\n\tuuidGenerator = __webpack_require__(10);\n\n\tProjectionService = (function() {\n\t  function ProjectionService(_context) {\n\t    this._context = _context;\n\t    this._logger = __webpack_require__(13).getLogger();\n\t    this._handlerFunctions = {};\n\t    this._projectionInstances = {};\n\t  }\n\n\t  ProjectionService.prototype.initializeInstance = function(projectionInstance, params) {\n\t    var aggregateId, diFn, diName, eventNames, projectionId, ref;\n\t    if (this._context._di) {\n\t      ref = this._context._di;\n\t      for (diName in ref) {\n\t        diFn = ref[diName];\n\t        projectionInstance[diName] = diFn;\n\t      }\n\t    }\n\t    projectionId = uuidGenerator.generateUuid();\n\t    aggregateId = null;\n\t    projectionInstance.$subscribeHandlersWithAggregateId = function(_aggregateId) {\n\t      if (!_aggregateId) {\n\t        throw new Error('Missing aggregate id');\n\t      }\n\t      return aggregateId = _aggregateId;\n\t    };\n\t    eventNames = null;\n\t    return this._callInitializeOnProjection(projectionInstance, params).then((function(_this) {\n\t      return function() {\n\t        return _this._parseEventNamesFromProjection(projectionInstance);\n\t      };\n\t    })(this)).then((function(_this) {\n\t      return function(_eventNames) {\n\t        eventNames = _eventNames;\n\t        return _this._applyDomainEventsFromStoreToProjection(projectionInstance, eventNames, aggregateId);\n\t      };\n\t    })(this)).then((function(_this) {\n\t      return function() {\n\t        return _this._subscribeProjectionToDomainEvents(projectionId, projectionInstance, eventNames, aggregateId);\n\t      };\n\t    })(this)).then((function(_this) {\n\t      return function() {\n\t        return _this._projectionInstances[projectionId] = projectionInstance;\n\t      };\n\t    })(this)).then(function() {\n\t      return projectionInstance.isInitialized = true;\n\t    }).then(function() {\n\t      return projectionId;\n\t    });\n\t  };\n\n\t  ProjectionService.prototype._callInitializeOnProjection = function(projection, params) {\n\t    return new Promise(function(resolve) {\n\t      if (!projection.initialize) {\n\t        return resolve(projection);\n\t      }\n\t      return projection.initialize(params, function() {\n\t        return resolve(projection);\n\t      });\n\t    });\n\t  };\n\n\t  ProjectionService.prototype._parseEventNamesFromProjection = function(projection) {\n\t    return new Promise(function(resolve) {\n\t      var eventName, eventNames, key, value;\n\t      eventNames = [];\n\t      for (key in projection) {\n\t        value = projection[key];\n\t        if ((key.indexOf('handle')) === 0 && (typeof value === 'function')) {\n\t          eventName = key.replace(/^handle/, '');\n\t          eventNames.push(eventName);\n\t        }\n\t      }\n\t      return resolve(eventNames);\n\t    });\n\t  };\n\n\t  ProjectionService.prototype._applyDomainEventsFromStoreToProjection = function(projection, eventNames, aggregateId) {\n\t    var findEvents;\n\t    if (aggregateId) {\n\t      findEvents = this._context.findDomainEventsByNameAndAggregateId(eventNames, aggregateId);\n\t    } else {\n\t      findEvents = this._context.findDomainEventsByName(eventNames);\n\t    }\n\t    return findEvents.then((function(_this) {\n\t      return function(domainEvents) {\n\t        var applyDomainEventsToProjectionPromise;\n\t        if (!domainEvents || domainEvents.length === 0) {\n\t          return;\n\t        }\n\t        applyDomainEventsToProjectionPromise = Promise.resolve();\n\t        domainEvents.forEach(function(domainEvent) {\n\t          return applyDomainEventsToProjectionPromise = applyDomainEventsToProjectionPromise.then(function() {\n\t            return _this._applyDomainEventToProjection(domainEvent, projection);\n\t          });\n\t        });\n\t        return applyDomainEventsToProjectionPromise;\n\t      };\n\t    })(this));\n\t  };\n\n\t  ProjectionService.prototype._subscribeProjectionToDomainEvents = function(projectionId, projection, eventNames, aggregateId) {\n\t    var domainEventHandler, subscribeProjectionToDomainEventsPromise;\n\t    domainEventHandler = (function(_this) {\n\t      return function(domainEvent) {\n\t        return _this._applyDomainEventToProjection(domainEvent, projection);\n\t      };\n\t    })(this);\n\t    this._handlerFunctions[projectionId] = [];\n\t    subscribeProjectionToDomainEventsPromise = Promise.resolve();\n\t    eventNames.forEach((function(_this) {\n\t      return function(eventName) {\n\t        return subscribeProjectionToDomainEventsPromise = subscribeProjectionToDomainEventsPromise.then(function() {\n\t          if (aggregateId) {\n\t            return _this._context.subscribeToDomainEventWithAggregateId(eventName, aggregateId, domainEventHandler);\n\t          } else {\n\t            return _this._context.subscribeToDomainEvent(eventName, domainEventHandler);\n\t          }\n\t        }).then(function(subscriberId) {\n\t          return _this._handlerFunctions[projectionId].push(subscriberId);\n\t        });\n\t      };\n\t    })(this));\n\t    return subscribeProjectionToDomainEventsPromise;\n\t  };\n\n\t  ProjectionService.prototype._applyDomainEventToProjection = function(domainEvent, projection) {\n\t    return Promise.resolve().then((function(_this) {\n\t      return function() {\n\t        if (!projection[\"handle\" + domainEvent.name]) {\n\t          _this._logger.warn(\"ProjectionService: handle\" + domainEvent.name + \" not defined\");\n\t        }\n\t        return projection[\"handle\" + domainEvent.name](domainEvent);\n\t      };\n\t    })(this));\n\t  };\n\n\t  ProjectionService.prototype.getInstance = function(projectionId) {\n\t    return this._projectionInstances[projectionId];\n\t  };\n\n\t  ProjectionService.prototype.destroyInstance = function(projectionId) {\n\t    var i, len, ref, subscriberId, unsubscribePromises;\n\t    if (!projectionId) {\n\t      return Promise.reject(new Error('Missing projection id'));\n\t    }\n\t    if (!this._handlerFunctions[projectionId]) {\n\t      return Promise.reject(new Error(\"Projection with id \\\"\" + projectionId + \"\\\" is not initialized\"));\n\t    }\n\t    unsubscribePromises = [];\n\t    ref = this._handlerFunctions[projectionId];\n\t    for (i = 0, len = ref.length; i < len; i++) {\n\t      subscriberId = ref[i];\n\t      unsubscribePromises.push(this._context.unsubscribeFromDomainEvent(subscriberId));\n\t    }\n\t    delete this._handlerFunctions[projectionId];\n\t    delete this._projectionInstances[projectionId];\n\t    return Promise.all(unsubscribePromises);\n\t  };\n\n\t  return ProjectionService;\n\n\t})();\n\n\tmodule.exports = ProjectionService;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(20);\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Remote;\n\n\tRemote = (function() {\n\t  Remote.ALLOWED_RPC_OPERATIONS = ['command', 'query', 'findDomainEventsByName', 'findDomainEventsByNameAndAggregateId'];\n\n\t  function Remote(_contextName) {\n\t    var Projection, inmemoryRemote;\n\t    this._contextName = _contextName;\n\t    Projection = __webpack_require__(17);\n\t    inmemoryRemote = __webpack_require__(21);\n\t    this._params = {};\n\t    this._handlerFunctions = {};\n\t    this._projectionService = new Projection(this);\n\t    this.setClient(inmemoryRemote.client);\n\t    this._exposeRpcOperationsAsMemberFunctions();\n\t  }\n\n\t  Remote.prototype._exposeRpcOperationsAsMemberFunctions = function() {\n\t    return Remote.ALLOWED_RPC_OPERATIONS.forEach((function(_this) {\n\t      return function(rpcOperation) {\n\t        return _this[rpcOperation] = function() {\n\t          return _this._rpc(rpcOperation, arguments);\n\t        };\n\t      };\n\t    })(this));\n\t  };\n\n\t  Remote.prototype.subscribeToAllDomainEvents = function(handlerFn) {\n\t    return this._client.subscribe(this._contextName, handlerFn);\n\t  };\n\n\t  Remote.prototype.subscribeToDomainEvent = function(domainEventName, handlerFn) {\n\t    return this._client.subscribe(this._contextName, domainEventName, handlerFn);\n\t  };\n\n\t  Remote.prototype.subscribeToDomainEventWithAggregateId = function(domainEventName, aggregateId, handlerFn) {\n\t    return this._client.subscribe(this._contextName, domainEventName, aggregateId, handlerFn);\n\t  };\n\n\t  Remote.prototype.unsubscribeFromDomainEvent = function(subscriberId) {\n\t    return this._client.unsubscribe(subscriberId);\n\t  };\n\n\t  Remote.prototype._rpc = function(functionName, args) {\n\t    return this._client.rpc({\n\t      contextName: this._contextName,\n\t      functionName: functionName,\n\t      args: Array.prototype.slice.call(args)\n\t    });\n\t  };\n\n\t  Remote.prototype.setClient = function(client) {\n\t    this._client = client;\n\t    return this;\n\t  };\n\n\t  Remote.prototype.initializeProjection = function(projectionObject, params) {\n\t    return this._projectionService.initializeInstance(projectionObject, params);\n\t  };\n\n\t  Remote.prototype.destroyProjectionInstance = function(projectionId) {\n\t    return this._projectionService.destroyInstance(projectionId, this);\n\t  };\n\n\t  return Remote;\n\n\t})();\n\n\tmodule.exports = Remote;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"eventric-remote-inmemory\"] = factory();\n\t\telse\n\t\t\troot[\"eventric-remote-inmemory\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\n\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\n\t\tmodule.exports = {\n\t\t  endpoint: __webpack_require__(1),\n\t\t  client: __webpack_require__(3)\n\t\t};\n\n\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\n\t\tvar InMemoryRemoteEndpoint, pubSub,\n\t\t  slice = [].slice;\n\n\t\tpubSub = __webpack_require__(2);\n\n\t\tInMemoryRemoteEndpoint = (function() {\n\t\t  function InMemoryRemoteEndpoint() {}\n\n\t\t  InMemoryRemoteEndpoint.prototype.setRPCHandler = function(handleRPCRequest) {\n\t\t    this.handleRPCRequest = handleRPCRequest;\n\t\t  };\n\n\t\t  InMemoryRemoteEndpoint.prototype.publish = function() {\n\t\t    var aggregateId, arg, contextName, domainEventName, fullEventName, i, payload;\n\t\t    contextName = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), payload = arguments[i++];\n\t\t    domainEventName = arg[0], aggregateId = arg[1];\n\t\t    fullEventName = pubSub.getFullEventName(contextName, domainEventName, aggregateId);\n\t\t    return pubSub.publish(fullEventName, payload);\n\t\t  };\n\n\t\t  return InMemoryRemoteEndpoint;\n\n\t\t})();\n\n\t\tmodule.exports = new InMemoryRemoteEndpoint;\n\n\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\n\t\tvar PubSub,\n\t\t  slice = [].slice;\n\n\t\tPubSub = (function() {\n\t\t  function PubSub() {\n\t\t    this._subscribers = [];\n\t\t    this._subscriberId = 0;\n\t\t  }\n\n\t\t  PubSub.prototype.subscribe = function(eventName, subscriberFunction) {\n\t\t    return new Promise((function(_this) {\n\t\t      return function(resolve) {\n\t\t        var subscriber;\n\t\t        subscriber = {\n\t\t          eventName: eventName,\n\t\t          subscriberFunction: subscriberFunction,\n\t\t          subscriberId: _this._getNextSubscriberId()\n\t\t        };\n\t\t        _this._subscribers.push(subscriber);\n\t\t        return resolve(subscriber.subscriberId);\n\t\t      };\n\t\t    })(this));\n\t\t  };\n\n\t\t  PubSub.prototype.publish = function(eventName, payload) {\n\t\t    var subscribers;\n\t\t    subscribers = this._getRelevantSubscribers(eventName);\n\t\t    return Promise.all(subscribers.map(function(subscriber) {\n\t\t      return subscriber.subscriberFunction(payload);\n\t\t    }));\n\t\t  };\n\n\t\t  PubSub.prototype._getRelevantSubscribers = function(eventName) {\n\t\t    if (eventName) {\n\t\t      return this._subscribers.filter(function(subscriber) {\n\t\t        return subscriber.eventName === eventName;\n\t\t      });\n\t\t    } else {\n\t\t      return this._subscribers;\n\t\t    }\n\t\t  };\n\n\t\t  PubSub.prototype.unsubscribe = function(subscriberId) {\n\t\t    return new Promise((function(_this) {\n\t\t      return function(resolve) {\n\t\t        _this._subscribers = _this._subscribers.filter(function(subscriber) {\n\t\t          return subscriber.subscriberId !== subscriberId;\n\t\t        });\n\t\t        return resolve();\n\t\t      };\n\t\t    })(this));\n\t\t  };\n\n\t\t  PubSub.prototype._getNextSubscriberId = function() {\n\t\t    return this._subscriberId++;\n\t\t  };\n\n\t\t  PubSub.prototype.getFullEventName = function() {\n\t\t    var eventParts;\n\t\t    eventParts = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t\t    eventParts = eventParts.filter(function(eventPart) {\n\t\t      return eventPart != null;\n\t\t    });\n\t\t    return eventParts.join('/');\n\t\t  };\n\n\t\t  return PubSub;\n\n\t\t})();\n\n\t\tmodule.exports = new PubSub;\n\n\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\n\t\tvar InMemoryRemoteClient, endpoint, pubSub,\n\t\t  slice = [].slice;\n\n\t\tendpoint = __webpack_require__(1);\n\n\t\tpubSub = __webpack_require__(2);\n\n\t\tInMemoryRemoteClient = (function() {\n\t\t  function InMemoryRemoteClient() {}\n\n\t\t  InMemoryRemoteClient.prototype.rpc = function(rpcRequest) {\n\t\t    return new Promise((function(_this) {\n\t\t      return function(resolve, reject) {\n\t\t        return endpoint.handleRPCRequest(rpcRequest, function(error, result) {\n\t\t          if (error) {\n\t\t            return reject(error);\n\t\t          } else {\n\t\t            return resolve(result);\n\t\t          }\n\t\t        });\n\t\t      };\n\t\t    })(this));\n\t\t  };\n\n\t\t  InMemoryRemoteClient.prototype.subscribe = function() {\n\t\t    var aggregateId, arg, contextName, domainEventName, fullEventName, handlerFunction, i;\n\t\t    contextName = arguments[0], arg = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), handlerFunction = arguments[i++];\n\t\t    domainEventName = arg[0], aggregateId = arg[1];\n\t\t    fullEventName = pubSub.getFullEventName(contextName, domainEventName, aggregateId);\n\t\t    return pubSub.subscribe(fullEventName, handlerFunction);\n\t\t  };\n\n\t\t  InMemoryRemoteClient.prototype.unsubscribe = function(subscriberId) {\n\t\t    return pubSub.unsubscribe(subscriberId);\n\t\t  };\n\n\t\t  return InMemoryRemoteClient;\n\n\t\t})();\n\n\t\tmodule.exports = new InMemoryRemoteClient;\n\n\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(23);\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tvar Logger;\n\n\tLogger = (function() {\n\t  Logger.prototype.LOG_LEVELS = {\n\t    error: 0,\n\t    warn: 1,\n\t    info: 2,\n\t    debug: 3\n\t  };\n\n\t  function Logger() {\n\t    this.setLogLevel('warn');\n\t  }\n\n\t  Logger.prototype.setLogLevel = function(logLevel) {\n\t    if (this.LOG_LEVELS[logLevel] === void 0) {\n\t      throw new Error('Logger: No valid log level');\n\t    }\n\t    return this._logLevel = this.LOG_LEVELS[logLevel];\n\t  };\n\n\t  Logger.prototype.error = function() {\n\t    return console['error'].apply(console, arguments);\n\t  };\n\n\t  Logger.prototype.warn = function() {\n\t    if (this._logLevel < 1) {\n\t      return;\n\t    }\n\t    return console['warn'].apply(console, arguments);\n\t  };\n\n\t  Logger.prototype.info = function() {\n\t    if (this._logLevel < 2) {\n\t      return;\n\t    }\n\t    return console['info'].apply(console, arguments);\n\t  };\n\n\t  Logger.prototype.debug = function() {\n\t    if (this._logLevel < 3) {\n\t      return;\n\t    }\n\t    return console['log'].apply(console, arguments);\n\t  };\n\n\t  return Logger;\n\n\t})();\n\n\tmodule.exports = new Logger;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(25);\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar GlobalContext, domainEventService,\n\t  slice = [].slice;\n\n\tdomainEventService = __webpack_require__(12);\n\n\tGlobalContext = (function() {\n\t  function GlobalContext() {\n\t    this.name = 'Global';\n\t  }\n\n\t  GlobalContext.prototype.findDomainEventsByName = function() {\n\t    var domainEventsByContext, findArguments, findDomainEventsByNamePromise;\n\t    findArguments = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t    findDomainEventsByNamePromise = Promise.resolve();\n\t    domainEventsByContext = [];\n\t    this._getAllContexts().forEach(function(context) {\n\t      return findDomainEventsByNamePromise = findDomainEventsByNamePromise.then(function() {\n\t        return context.findDomainEventsByName.apply(context, findArguments).then(function(domainEvents) {\n\t          return domainEventsByContext.push(domainEvents);\n\t        });\n\t      });\n\t    });\n\t    return findDomainEventsByNamePromise.then((function(_this) {\n\t      return function() {\n\t        var domainEvents;\n\t        domainEvents = _this._combineDomainEventsByContext(domainEventsByContext);\n\t        domainEvents = domainEventService.sortDomainEventsById(domainEvents);\n\t        return domainEvents;\n\t      };\n\t    })(this));\n\t  };\n\n\t  GlobalContext.prototype.subscribeToDomainEvent = function(eventName, domainEventHandler) {\n\t    var subscribeToDomainEvents;\n\t    subscribeToDomainEvents = this._getAllContexts().map(function(context) {\n\t      return context.subscribeToDomainEvent(eventName, domainEventHandler);\n\t    });\n\t    return Promise.all(subscribeToDomainEvents);\n\t  };\n\n\t  GlobalContext.prototype._getAllContexts = function() {\n\t    var contextNames, eventric;\n\t    eventric = __webpack_require__(1);\n\t    contextNames = eventric.getRegisteredContextNames();\n\t    return contextNames.map(function(contextName) {\n\t      return eventric.remoteContext(contextName);\n\t    });\n\t  };\n\n\t  GlobalContext.prototype._combineDomainEventsByContext = function(domainEventsByContext) {\n\t    return domainEventsByContext.reduce(function(allDomainEvents, contextDomainEvents) {\n\t      return allDomainEvents.concat(contextDomainEvents);\n\t    }, []);\n\t  };\n\n\t  return GlobalContext;\n\n\t})();\n\n\tmodule.exports = GlobalContext;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tvar InMemoryStore;\n\n\tInMemoryStore = (function() {\n\t  InMemoryStore.prototype.domainEventSequence = {\n\t    currentDomainEventId: 1\n\t  };\n\n\t  function InMemoryStore() {\n\t    this._domainEvents = [];\n\t  }\n\n\t  InMemoryStore.prototype.initialize = function(_context) {\n\t    this._context = _context;\n\t    return new Promise((function(_this) {\n\t      return function(resolve) {\n\t        _this._domainEventsCollectionName = _this._context.name + \".DomainEvents\";\n\t        return resolve();\n\t      };\n\t    })(this));\n\t  };\n\n\t  InMemoryStore.prototype.saveDomainEvent = function(domainEvent) {\n\t    return new Promise((function(_this) {\n\t      return function(resolve) {\n\t        domainEvent.id = _this.domainEventSequence.currentDomainEventId++;\n\t        _this._domainEvents.push(domainEvent);\n\t        return resolve(domainEvent);\n\t      };\n\t    })(this));\n\t  };\n\n\t  InMemoryStore.prototype.findDomainEventsByName = function(domainEventNames, callback) {\n\t    var events;\n\t    if (!(domainEventNames instanceof Array)) {\n\t      domainEventNames = [domainEventNames];\n\t    }\n\t    events = this._domainEvents.filter(function(domainEvent) {\n\t      return domainEventNames.indexOf(domainEvent.name) > -1;\n\t    });\n\t    return callback(null, events);\n\t  };\n\n\t  InMemoryStore.prototype.findDomainEventsByAggregateId = function(aggregateIds, callback) {\n\t    var domainEvents;\n\t    if (!(aggregateIds instanceof Array)) {\n\t      aggregateIds = [aggregateIds];\n\t    }\n\t    domainEvents = this._domainEvents.filter(function(domainEvent) {\n\t      return aggregateIds.indexOf(domainEvent.aggregate.id) > -1;\n\t    });\n\t    return callback(null, domainEvents);\n\t  };\n\n\t  InMemoryStore.prototype.findDomainEventsByNameAndAggregateId = function(domainEventNames, aggregateIds, callback) {\n\t    var domainEvents;\n\t    if (!(domainEventNames instanceof Array)) {\n\t      domainEventNames = [domainEventNames];\n\t    }\n\t    if (!(aggregateIds instanceof Array)) {\n\t      aggregateIds = [aggregateIds];\n\t    }\n\t    domainEvents = this._domainEvents.filter(function(domainEvent) {\n\t      return domainEventNames.indexOf(domainEvent.name) > -1 && aggregateIds.indexOf(domainEvent.aggregate.id) > -1;\n\t    });\n\t    return callback(null, domainEvents);\n\t  };\n\n\t  InMemoryStore.prototype.destroy = function() {\n\t    return Promise.resolve();\n\t  };\n\n\t  return InMemoryStore;\n\n\t})();\n\n\tmodule.exports = InMemoryStore;\n\n\n/***/ }\n/******/ ])\n});\n;","/home/travis/build/npmtest/node-npmtest-eventric/node_modules/eventric/gulpfile.js":"require('coffee-script/register');\nrequire('./gulpfile.coffee');\n","/home/travis/build/npmtest/node-npmtest-eventric/node_modules/eventric/karma.conf.js":"require('coffee-script/register');\nmodule.exports = require('./karma.conf.coffee');\n"}